const fs = require('fs');
const path = require('path');
const tokenizing = require('./tokenization.js');


/* need to install these */
const { DOMParser } = require('xmldom');


/* create xml file paths for these file*/
const cf74 = path.join(__dirname, '../cfcFiles/cf74.xml');
const cf75 = path.join(__dirname, '../cfcFiles/cf75.xml');
const cf76 = path.join(__dirname, '../cfcFiles/cf76.xml');
const cf77 = path.join(__dirname, '../cfcFiles/cf77.xml');
const cf78 = path.join(__dirname, '../cfcFiles/cf78.xml');
const cf79 = path.join(__dirname, '../cfcFiles/cf79.xml');

/* convert xml file to string */
const cfcFiles = [
  cf74,
  cf75,
  cf76,
  cf77,
  cf78,
  cf79
]
const cfcStrings = [];

// convert cfcFiles to cfc Strings
function buildCfcStrings(){
  for(let cfcFile of cfcFiles){
    cfcStrings.push(fs.readFileSync(cfcFile, 'utf8'));
  }
}

let autogenerated = 0;
const tagsNeeded = ['ABSTRACT','EXTRACT'];
const allDocs = {};

/*
* This function is to parse each CFC file from 'Record'
*/
async function readAllXML(){
  buildCfcStrings();
  for( let cfcString of cfcStrings){
    const doc = new DOMParser().parseFromString(cfcString);
    const records = doc.getElementsByTagName('RECORD');
    await readXML(records);
  }
}


/*
* Parse and extra meaningful tags from XML string
*/
async function readXML (records) {
  for(let index = 0; index < records.length; index++){
    const RECORDNUM = records[index].getElementsByTagName('RECORDNUM')[0];

    // get recordnum for each record
    const record_id = (RECORDNUM == undefined) ? autogenerated:RECORDNUM.childNodes[0].data;
    autogenerated++; // increment

    // retrieve meaningful text from tags
    for(const tag of tagsNeeded){
      const TAG = records[index].getElementsByTagName(tag)[0];
      const tag_text = (TAG == undefined) ? '':TAG.childNodes[0].data;
      if(tag_text.length > 0){
          await buildAllDocs(record_id, tag, tag_text);
      }
    }
    let status = autogenerated/1239 * 100;
    //console.log(autogenerated/1239, "docs has been parsed and tokenized");
    console.log("%s% docs has been parsed and tokenized",status.toFixed(2));
  }
}

/*
* Build a dictionary
*/
function buildAllDocs(record_id, tag, tag_text){
  if(allDocs[record_id]==undefined){
    allDocs[record_id] = new Object();
    allDocs[record_id].id = parseInt(record_id);
  }
  let newText = tokenizing(tag_text);
  allDocs[record_id].text = newText;
}







// const invertedIndex = {};
/*
invertedIndex = {
  'word' = {
      'records': {
          'docId':{
              counts: 0,
              weighted term frequency (w):
            },
      'idf'
    }
  }
}
*/
// function indexing (record_id, words){
//   let docSize = words.length; // unique word size in the doc
//   if(docSize>0){
//     for( let word of words ){
//       if(invertedIndex[word] == undefined){
//         invertedIndex[word] = new Object();
//         invertedIndex[word].records = new Object();
//         invertedIndex[word].idf = 0;
//         invertedIndex[word].word = word
//       }
//
//       if(invertedIndex[word].records[record_id] == undefined){
//         invertedIndex[word].records[record_id] = new Object();
//         invertedIndex[word].records[record_id].count = 0;
//         invertedIndex[word].records[record_id].w = 0;
//       }
//       invertedIndex[word].records[record_id].count++;
//       invertedIndex[word].records[record_id].w = invertedIndex[word].records[record_id].count / docSize;
//     }
//   }
//
// }

module.exports = {
    readAllXML, allDocs
}
